/*
classgen is a tool for generating classes based on Unicode Character Data.

classgen has the following flags:

	-noclass          : disable `type Class` generation
	-x <prefix>       : prefix to categories, used for table naming
    -f <n>            : field index of the character category
    -o <filename>     : output file (default tables.go)
    -u <filename>     : ucd data file name in ./internal/testdata/ucd

License

Governed by a 3-Clause BSD license. License file may be found in the root
folder of this module.

Copyright © 2021 Norbert Pillmayer <norbert@pillmayer.com>
*/
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unsafe"

	"github.com/npillmayer/uax/internal/testdata"
	"github.com/npillmayer/uax/internal/ucdparse"
	"golang.org/x/text/unicode/rangetable"
)

func main() {
	noClass := flag.Bool("noclass", false, "disable class generator")
	prefix := flag.String("x", "", "prefix to categories, used for class and table naming")
	categoryField := flag.Int("f", 2, "field position of category field, 1…n")
	outName := flag.String("o", "tables.go", "name of output source file")
	ucdFile := flag.String("u", "", "UCD filename")

	flag.Parse()

	codePointLists, err := parseRanges(*ucdFile, *categoryField)
	checkFatal(err)

	classes := []string{}
	for class := range codePointLists {
		classes = append(classes, class)
	}
	sort.Strings(classes)

	rangeTables := map[string]*unicode.RangeTable{}
	for class, runes := range codePointLists {
		rangeTables[class] = rangetable.New(runes...)
	}

	var w bytes.Buffer
	terr := T.Execute(&w, map[string]interface{}{
		"GenerateClass": !*noClass,
		"Prefix":        *prefix,
		"PackageName":   os.Getenv("GOPACKAGE"),
		"Classes":       classes,
		"RangeTables":   rangeTables,
		"Codepoints":    codePointLists,
	})
	checkFatal(terr)

	formatted, err := format.Source(w.Bytes())
	checkFatal(err)

	err = ioutil.WriteFile(*outName, formatted, 0644)
	checkFatal(err)
}

func parseRanges(ucdfile string, categoryField int) (map[string][]rune, error) {
	ucddata, err := os.ReadFile(testdata.UCDPath(ucdfile))
	if err != nil {
		return nil, fmt.Errorf("failed to read %q: %w", ucdfile, err)
	}

	parser, err := ucdparse.New(bytes.NewReader(ucddata))
	if err != nil {
		return nil, err
	}

	ranges := map[string][]rune{}
	for parser.Next() {
		from, to := parser.Token.Range()

		class := strings.TrimSpace(parser.Token.Field(categoryField - 1))
		if class == "" {
			// Not quite sure why this happens.
			continue
		}

		list := ranges[class]
		for r := from; r <= to; r++ {
			list = append(list, r)
		}
		ranges[class] = list
	}

	if err = parser.Token.Error; err != nil {
		return nil, fmt.Errorf("ucdparse failed: %w", err)
	}

	return ranges, err
}

var T = template.Must(template.New("").Funcs(template.FuncMap{
	"size": func(rt *unicode.RangeTable) string {
		sz := int(unsafe.Sizeof(*rt))
		sz += int(unsafe.Sizeof(rt.R16[0])) * len(rt.R16)
		sz += int(unsafe.Sizeof(rt.R32[0])) * len(rt.R32)
		return fmt.Sprintf("size %d bytes (%.2f KiB)", sz, float64(sz)/1024)
	},
	"pretty": func(rt *unicode.RangeTable) string {
		s := "&unicode.RangeTable{\n"
		if len(rt.R16) > 0 {
			s += "\tR16: []unicode.Range16{\n"
			for _, r := range rt.R16 {
				s += fmt.Sprintf("\t\t{%#x, %#x, %d},\n", r.Lo, r.Hi, r.Stride)
			}
			s += "\t},\n"
		}
		if len(rt.R32) > 0 {
			s += "\tR32: []unicode.Range32{\n"
			for _, r := range rt.R32 {
				s += fmt.Sprintf("\t\t{%#x, %#x, %d},\n", r.Lo, r.Hi, r.Stride)
			}
			s += "\t},\n"
		}
		if rt.LatinOffset > 0 {
			s += fmt.Sprintf("\tLatinOffset: %d,\n", rt.LatinOffset)
		}
		s += "}"
		return s
	},
}).Parse(`// Code generated by github.com/npillmayer/uax/internal/classgen DO NOT EDIT
//
// BSD License, Copyright (c) 2018, Norbert Pillmayer (norbert@pillmayer.com)

package {{.PackageName}}

import (
    {{ if .GenerateClass }}"strconv"{{ end }}
    "unicode"
)
{{ $prefix := .Prefix }}
{{ if .GenerateClass }}
// {{.Prefix}}Class for {{.PackageName}}.
// Must be convertable to int.
type {{$prefix}}Class int

const (
{{ range $i, $class := .Classes }}
	{{$class}}{{$prefix}}Class {{$prefix}}Class = {{$i}}
{{- end }}

	{{$prefix}}Other {{$prefix}}Class = -1 // pseudo class for any other
	{{$prefix}}sot   {{$prefix}}Class = -2 // pseudo class "start of text"
	{{$prefix}}eot   {{$prefix}}Class = -3 // pseudo class "end of text"
)

// String returns the Class name.
func (c {{$prefix}}Class) String() string {
	switch c {
	case {{$prefix}}Other: return "Other"
	case {{$prefix}}sot: return "sot"
	case {{$prefix}}eot: return "eot"
	default:
		return "{{$prefix}}Class(" + strconv.Itoa(int(c)) + ")"
{{- range $i, $class := .Classes }}
	case {{$class}}{{$prefix}}Class: return "{{ $class }}Class"
{{- end }}
	}
}

var rangeFrom{{$prefix}}Class = []*unicode.RangeTable{
{{- range $i, $class := .Classes }}
	{{$class}}{{$prefix}}Class: {{$class}},
{{- end }}
}
{{ end }}

// Range tables for {{.PackageName}} classes.
// Clients can check with unicode.Is(..., rune)
var (
{{ range $i, $class := .Classes }}
	{{$prefix}}{{$class}} = _{{$prefix}}{{$class}}
{{- end }}
)

{{ range $class, $rt := .RangeTables }}
// {{ size $rt }}
var _{{$prefix}}{{ $class }} = {{ pretty $rt }}
{{ end }}
`))

func checkFatal(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
